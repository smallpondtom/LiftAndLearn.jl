<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · LiftAndLearn.jl</title><meta name="title" content="API Reference · LiftAndLearn.jl"/><meta property="og:title" content="API Reference · LiftAndLearn.jl"/><meta property="twitter:title" content="API Reference · LiftAndLearn.jl"/><meta name="description" content="Documentation for LiftAndLearn.jl."/><meta property="og:description" content="Documentation for LiftAndLearn.jl."/><meta property="twitter:description" content="Documentation for LiftAndLearn.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-B2FEJZ9J99"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B2FEJZ9J99', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="LiftAndLearn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">LiftAndLearn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/Utilities/">Utilities</a></li><li><a class="tocitem" href="../manual/Options/">Options</a></li><li><a class="tocitem" href="../manual/Lift/">Lift</a></li><li><a class="tocitem" href="../manual/Intrusive/">Intrusive</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Non-Intrusive</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../manual/nonintrusive/LS/">Standard OpInf</a></li><li><a class="tocitem" href="../manual/nonintrusive/LnL/">Lift And Learn</a></li><li><a class="tocitem" href="../manual/nonintrusive/EPOpInf/">Energy Preserving</a></li></ul></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../models/Heat1D/">Heat1D</a></li><li><a class="tocitem" href="../models/Burgers/">Burgers</a></li><li><a class="tocitem" href="../models/FHN/">FHN</a></li><li><a class="tocitem" href="../models/KS/">KS</a></li></ul></li><li class="is-active"><a class="tocitem" href>API Reference</a></li><li><a class="tocitem" href="../paper/">Paper Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/smallpondtom/LiftAndLearn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/https://github.com/smallpondtom/LiftAndLearn.jl/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#API">API</a></li></ul><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>All APIs of LiftAndLearn listed in a unstructured manner.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.EPConstraintResidual" href="#LiftAndLearn.EPConstraintResidual"><code>LiftAndLearn.EPConstraintResidual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">EPConstraintResidual(X, r, which_quad=&quot;H&quot;; with_mmt=false) → ϵX, mmt</code></pre><p>Compute the constraint residual which is the residual of the energy-preserving constraint </p><p class="math-container">\[\sum \left| \hat{h}_{ijk} + \hat{h}_{jik} + \hat{h}_{kji} \right| \quad 1 \leq i,j,k \leq r\]</p><p><strong>Arguments</strong></p><ul><li><code>X::Union{Matrix,SparseMatrixCSC}</code>: the matrix to compute the constraint residual</li><li><code>r::Real</code>: the dimension of the system</li><li><code>which_quad::String</code>: the type of the quadratic operator (H or F)</li><li><code>with_mmt::Bool</code>: whether to compute the moment of the constraint residual</li></ul><p><strong>Returns</strong></p><ul><li><code>ϵX</code>: the constraint residual</li><li><code>mmt</code>: the moment which is the sum of the constraint residual without absolute value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/analyze.jl#L104-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.EPConstraintViolation" href="#LiftAndLearn.EPConstraintViolation"><code>LiftAndLearn.EPConstraintViolation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">EPConstraintViolation(Data, X, which_quad=&quot;H&quot;) → viol</code></pre><p>Compute the constraint violation which is the violation of the energy-preserving constraint</p><p class="math-container">\[\sum \langle \mathbf{x}, \mathbf{H}(\mathbf{x}\otimes\mathbf{x})\rangle \quad \forall \mathbf{x} \in \mathcal{D}\]</p><p><strong>Arguments</strong></p><ul><li><code>Data::AbstractArray</code>: the data</li><li><code>X::Union{Matrix,SparseMatrixCSC}</code>: the matrix to compute the constraint violation</li><li><code>which_quad::String</code>: the type of the quadratic operator (H or F)</li></ul><p><strong>Returns</strong></p><ul><li><code>viol</code>: the constraint violation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/analyze.jl#L158-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.EPHEC_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}" href="#LiftAndLearn.EPHEC_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}"><code>LiftAndLearn.EPHEC_Optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EPHEC_Optimize(D::Matrix, Rt::Union{Matrix,Transpose}, dims::Dict, 
    options::Abstract_Options, IG::operators) → Ahat, Bhat, Fhat, Hhat, Nhat, Khat</code></pre><p>Energy preserved (Hard Equality Constraint) operator inference optimization (EPHEC)</p><p><strong>Arguments</strong></p><ul><li><code>D</code>: data matrix</li><li><code>Rt</code>: transpose of the derivative matrix</li><li><code>dims</code>: important dimensions</li><li><code>options</code>: options for the operator inference set by the user</li><li><code>IG</code>: Initial Guesses</li></ul><p><strong>Returns</strong></p><ul><li>Inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/optimizer/EP_Optimize.jl#L3-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.EPP_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}" href="#LiftAndLearn.EPP_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}"><code>LiftAndLearn.EPP_Optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EPP_Optimize(D::Matrix, Rt::Union{Matrix,Transpose}, dims::Dict, 
    options::Abstract_Options, IG::operators) → Ahat, Bhat, Fhat, Hhat, Nhat, Khat</code></pre><p>Energy preserving penalty operator inference optimization (EPP)</p><p><strong>Arguments</strong></p><ul><li><code>D</code>: data matrix</li><li><code>Rt</code>: transpose of the derivative matrix</li><li><code>dims</code>: important dimensions</li><li><code>options</code>: options for the operator inference set by the user</li><li><code>IG</code>: Initial Guesses</li></ul><p><strong>Returns</strong></p><ul><li>Inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/optimizer/EP_Optimize.jl#L416-L432">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.EPSIC_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}" href="#LiftAndLearn.EPSIC_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}"><code>LiftAndLearn.EPSIC_Optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">EPSIC_Optimize(D::Matrix, Rt::Union{Matrix,Transpose}, dims::Dict, 
    options::Abstract_Options, IG::operators) → Ahat, Bhat, Fhat, Hhat, Nhat, Khat</code></pre><p>Energy preserved (Soft Inequality Constraint) operator inference optimization (EPSIC)</p><p><strong>Arguments</strong></p><ul><li><code>D</code>: data matrix</li><li><code>Rt</code>: transpose of the derivative matrix</li><li><code>dims</code>: important dimensions</li><li><code>options</code>: options for the operator inference set by the user</li><li><code>IG</code>: Initial Guesses</li></ul><p><strong>Returns</strong></p><ul><li>Inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/optimizer/EP_Optimize.jl#L198-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.F2H-Tuple{Any}" href="#LiftAndLearn.F2H-Tuple{Any}"><code>LiftAndLearn.F2H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F2H(F::Union{SparseMatrixCSC,VecOrMat}) → H</code></pre><p>Convert the quadratic <code>F</code> operator into the <code>H</code> operator</p><p><strong>Arguments</strong></p><ul><li><code>F</code>: F matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>H</code>: H matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L229-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.F2Hs-Tuple{Any}" href="#LiftAndLearn.F2Hs-Tuple{Any}"><code>LiftAndLearn.F2Hs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F2Hs(F::Union{SparseMatrixCSC,VecOrMat}) → Hs</code></pre><p>Convert the quadratic <code>F</code> operator into the symmetric <code>H</code> operator.</p><p>This guarantees that the <code>H</code> operator is symmetric. The difference from F2H is that we use the elimination matrix <code>L</code> and the symmetric commutation matrix <code>N</code> to multiply the <code>F</code> matrix.</p><p><strong>Arguments</strong></p><ul><li><code>F</code>: F matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>Hs</code>: symmetric H matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L265-L278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.H2F-Tuple{Any}" href="#LiftAndLearn.H2F-Tuple{Any}"><code>LiftAndLearn.H2F</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H2F(H::Union{SparseMatrixCSC,VecOrMat}) → F</code></pre><p>Convert the quadratic <code>H</code> operator into the <code>F</code> operator</p><p><strong>Arguments</strong></p><ul><li><code>H</code>: H matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>F</code>: F matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L247-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.H2Q-Tuple{AbstractArray}" href="#LiftAndLearn.H2Q-Tuple{AbstractArray}"><code>LiftAndLearn.H2Q</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">H2Q(H::AbstractArray) → Q</code></pre><p>Convert the quadratic <code>H</code> operator into the <code>Q</code> operator</p><p><strong>Arguments</strong></p><ul><li><code>H::AbstractArray</code>: Quadratic matrix of dimensions <code>(n x n^2)</code></li></ul><p><strong>Returns</strong></p><ul><li>the <code>Q</code> quadratic matrix of 3-dim tensor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L532-L542">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.LS_solve-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.LS_solve-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.LS_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LS_solve(D::Matrix, Rt::Union{Matrix,Transpose}, Y::Matrix, Xhat_t::Union{Matrix,Transpose}, 
    dims::Dict, options::Abstract_Options) → Ahat, Bhat, Chat, Fhat, Hhat, Nhat, Khat</code></pre><p>Solve the standard Operator Inference with/without regularization</p><p><strong>Arguments</strong></p><ul><li><code>D::Matrix</code>: data matrix</li><li><code>Rt::Union{Matrix,Transpose}</code>: derivative data matrix (transposed)</li><li><code>Y::Matrix</code>: output data matrix</li><li><code>Xhat_t::Union{Matrix,Transpose}</code>: projected data matrix (transposed)</li><li><code>dims::Dict</code>: dictionary including important dimensions</li><li><code>options::Abstract_Options</code>: options for the operator inference set by the user</li></ul><p><strong>Returns</strong></p><ul><li>All learned operators A, B, C, F, H, N, K</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L228-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.NC_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}" href="#LiftAndLearn.NC_Optimize-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options, operators}"><code>LiftAndLearn.NC_Optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NC_Optimize(D::Matrix, Rt::Union{Matrix, Transpose}, dims::Dict, 
    options::Abstract_Options, IG::operators) → Ahat, Bhat, Fhat, Hhat, Nhat, Khat</code></pre><p>Optimization version of Standard Operator Inference (NC)</p><p><strong>Arguments</strong></p><ul><li><code>D</code>: data matrix</li><li><code>Rt</code>: transpose of the derivative matrix</li><li><code>dims</code>: important dimensions</li><li><code>options</code>: options for the operator inference set by the user</li><li><code>IG</code>: Initial Guesses</li></ul><p><strong>Returns</strong></p><ul><li>Inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/optimizer/NC_Optimize.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.NC_Optimize_output-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.NC_Optimize_output-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Dict, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.NC_Optimize_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NC_Optimize_output(Y::Matrix, Xt_hat::Union{Matrix, Transpose}, dims::Dict, options::Abstract_Options) → C</code></pre><p>Output optimization for the standard operator inference (for operator <code>C</code>)</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: the output matrix </li><li><code>Xt_hat</code>: the state matrix</li></ul><p><strong>Return</strong></p><ul><li>the output state matrix <code>C</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/optimizer/NC_Optimize.jl#L143-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.Q2H-Tuple{AbstractArray}" href="#LiftAndLearn.Q2H-Tuple{AbstractArray}"><code>LiftAndLearn.Q2H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Q2H(Q::AbstractArray) → H</code></pre><p>Convert the quadratic <code>Q</code> operator into the <code>H</code> operator. The <code>Q</code> matrix is  a 3-dim tensor with dimensions <code>(n x n x n)</code>. Thus,</p><p class="math-container">\[\mathbf{Q} = \begin{bmatrix} 
    \mathbf{Q}_1 \\ 
    \mathbf{Q}_2 \\ 
    \vdots \\ 
    \mathbf{Q}_n 
\end{bmatrix}
\quad \text{where }~~ \mathbf{Q}_i \in \mathbb{R}^{n \times n}\]</p><p><strong>Arguments</strong></p><ul><li><code>Q::AbstractArray</code>: Quadratic matrix in the 3-dim tensor form with dimensions <code>(n x n x n)</code></li></ul><p><strong>Returns</strong></p><ul><li>the <code>H</code> quadratic matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L495-L516">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.backwardEuler-NTuple{5, Any}" href="#LiftAndLearn.backwardEuler-NTuple{5, Any}"><code>LiftAndLearn.backwardEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">backwardEuler(A, B, U, tdata, IC)
</code></pre><p>Backward Euler scheme integration.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: linear state operator</li><li><code>B</code>: linear input operator</li><li><code>U</code>: input data</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial condtions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.choose_ro-Tuple{Vector{T} where T}" href="#LiftAndLearn.choose_ro-Tuple{Vector{T} where T}"><code>LiftAndLearn.choose_ro</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">choose_ro(Σ::Vector; en_low=-15) → r_all, en</code></pre><p>Choose reduced order (ro) that preserves an acceptable energy.</p><p><strong>Arguments</strong></p><ul><li><code>Σ::Vector</code>: Singular value vector from the SVD of some Hankel Matrix</li><li><code>en_low</code>: minimum size for energy preservation</li></ul><p><strong>Returns</strong></p><ul><li><code>r_all</code>: vector of reduced orders</li><li><code>en</code>: vector of energy values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.commat-Tuple{Integer, Integer}" href="#LiftAndLearn.commat-Tuple{Integer, Integer}"><code>LiftAndLearn.commat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commat(m::Integer, n::Integer) → K</code></pre><p>Create commutation matrix <code>K</code> of dimension <code>m x n</code> <sup class="footnote-reference"><a id="citeref-magnus1980" href="#footnote-magnus1980">[magnus1980]</a></sup>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Integer</code>: row dimension of the commutation matrix</li><li><code>n::Integer</code>: column dimension of the commutation matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>K</code>: commutation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L125-L136">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.commat-Tuple{Integer}" href="#LiftAndLearn.commat-Tuple{Integer}"><code>LiftAndLearn.commat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">commat(m::Integer) → K</code></pre><p>Dispatch for the commutation matrix of dimensions (m, m)</p><p><strong>Arguments</strong></p><ul><li><code>m::Integer</code>: row and column dimension of the commutation matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>K</code>: commutation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L147-L157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.compError-NTuple{7, Any}" href="#LiftAndLearn.compError-NTuple{7, Any}"><code>LiftAndLearn.compError</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compError(Xf, Yf, Xint, Yint, Xinf, Yinf, Vr) → PE, ISE, IOE, OSE, OOE</code></pre><p>Compute all projection, state, and output errors</p><p><strong>Arguments</strong></p><ul><li><code>Xf</code>: reference state data</li><li><code>Yf</code>: reference output data</li><li><code>Xint</code>: intrusive model state data</li><li><code>Yint</code>: intrusive model output data</li><li><code>Xinf</code>: inferred model state data</li><li><code>Xint</code>: inferrred model output data</li><li><code>Vr</code>: POD basis</li></ul><p><strong>Return</strong></p><ul><li><code>PE</code>: projection error</li><li><code>ISE</code>: intrusive state error</li><li><code>IOE</code>: intrusive output error</li><li><code>OSE</code>: operator inference state error</li><li><code>OOE</code>: operator inference output error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/analyze.jl#L65-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.compOutputError-Tuple{Any, Any}" href="#LiftAndLearn.compOutputError-Tuple{Any, Any}"><code>LiftAndLearn.compOutputError</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compOutputError(Yf, Y) → OE</code></pre><p>Compute output error</p><p><strong>Arguments</strong></p><ul><li><code>Yf</code>: reference output data</li><li><code>Y</code>: testing output data</li></ul><p><strong>Return</strong></p><ul><li><code>OE</code>: output error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/analyze.jl#L45-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.compProjError-Tuple{Any, Any}" href="#LiftAndLearn.compProjError-Tuple{Any, Any}"><code>LiftAndLearn.compProjError</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compProjError(Xf, Vr) → PE</code></pre><p>Compute the projection error</p><p><strong>Arguments</strong></p><ul><li><code>Xf</code>: reference state data</li><li><code>Vr</code>: POD basis</li></ul><p><strong>Return</strong></p><ul><li><code>PE</code>: projection error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/analyze.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.compStateError-Tuple{Any, Any, Any}" href="#LiftAndLearn.compStateError-Tuple{Any, Any, Any}"><code>LiftAndLearn.compStateError</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compStateError(Xf, X, Vr) → SE</code></pre><p>Compute the state error</p><p><strong>Arguments</strong></p><ul><li><code>Xf</code>: reference state data</li><li><code>X</code>: testing state data</li><li><code>Vr</code>: POD basis</li></ul><p><strong>Return</strong></p><ul><li><code>SE</code>: state error</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/analyze.jl#L24-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.crankNicolson-NTuple{5, Any}" href="#LiftAndLearn.crankNicolson-NTuple{5, Any}"><code>LiftAndLearn.crankNicolson</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crankNicolson(A, B, U, tdata, IC)
</code></pre><p>Crank-Nicolson scheme</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: linear state operator</li><li><code>B</code>: linear input operator</li><li><code>U</code>: input data</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial condtions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L113">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.delta-Tuple{Any, Any}" href="#LiftAndLearn.delta-Tuple{Any, Any}"><code>LiftAndLearn.delta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">delta(v::Int, w::Int) → Float64</code></pre><p>Another auxiliary function for the <code>F</code> matrix</p><p><strong>Arguments</strong></p><ul><li><code>v</code>: first index</li><li><code>w</code>: second index</li></ul><p><strong>Returns</strong></p><ul><li>coefficient of 1.0 or 0.5</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L580-L591">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.dtApprox-Tuple{VecOrMat{T} where T, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.dtApprox-Tuple{VecOrMat{T} where T, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.dtApprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dtApprox(X::VecOrMat, options::Abstract_Options) → dXdt, idx</code></pre><p>Approximating the derivative values of the data with different integration schemes</p><p><strong>Arguments</strong></p><ul><li><code>X::VecOrMat</code>: data matrix</li><li><code>options::Abstract_Options</code>: operator inference options</li></ul><p><strong>Returns</strong></p><ul><li><code>dXdt</code>: derivative data</li><li><code>idx</code>: index for the specific integration scheme (important for later use)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.dupmat-Tuple{Any}" href="#LiftAndLearn.dupmat-Tuple{Any}"><code>LiftAndLearn.dupmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dupmat(n::Integer) → D</code></pre><p>Create duplication matrix <code>D</code> of dimension <code>n</code> <sup class="footnote-reference"><a id="citeref-magnus1980" href="#footnote-magnus1980">[magnus1980]</a></sup>.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: dimension of the duplication matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>D</code>: duplication matrix</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; A = [1 2; 3 4]
2×2 Matrix{Int64}:
 1  3
 3  4

julia&gt; D = LnL.dupmat(2)
4×3 SparseArrays.SparseMatrixCSC{Float64, Int64} with 4 stored entries:
 1.0   ⋅    ⋅ 
  ⋅   1.0   ⋅
  ⋅   1.0   ⋅
  ⋅    ⋅   1.0

julia&gt; D * LnL.vech(A)
4-element Vector{Float64}:
 1.0
 3.0
 3.0
 4.0

julia&gt; a = vec(A)
4-element Vector{Int64}:
 1
 3
 3
 4</code></pre><p><strong>References</strong></p><p><sup class="footnote-reference"><a id="citeref-magnus1980" href="#footnote-magnus1980">[magnus1980]</a></sup> J. R. Magnus and H. Neudecker, “The Elimination Matrix: Some Lemmas and Applications,”  SIAM. J. on Algebraic and Discrete Methods, vol. 1, no. 4, pp. 422–449, Dec. 1980, doi: 10.1137/0601049.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L35-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.elimat-Tuple{Any}" href="#LiftAndLearn.elimat-Tuple{Any}"><code>LiftAndLearn.elimat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">elimat(m::Integer) → L</code></pre><p>Create elimination matrix <code>L</code> of dimension <code>m</code> <sup class="footnote-reference"><a id="citeref-magnus1980" href="#footnote-magnus1980">[magnus1980]</a></sup>.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: dimension of the target matrix</li></ul><p><strong>Return</strong></p><ul><li><code>L</code>: elimination matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.extractF-Tuple{Any, Any}" href="#LiftAndLearn.extractF-Tuple{Any, Any}"><code>LiftAndLearn.extractF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractF(F::Union{SparseMatrixCSC,VecOrMat}, r::Int) → F</code></pre><p>Extracting the <code>F</code> matrix for POD basis of dimensions <code>(N, r)</code></p><p><strong>Arguments</strong></p><ul><li><code>F</code>: F matrix</li><li><code>r</code>: reduced order</li></ul><p><strong>Returns</strong></p><ul><li>extracted <code>F</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L329-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.extractH-Tuple{Any, Any}" href="#LiftAndLearn.extractH-Tuple{Any, Any}"><code>LiftAndLearn.extractH</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extractH(H::Union{SparseMatrixCSC,VecOrMat}, r::Int) → H</code></pre><p>Extracting the <code>H</code> matrix for POD basis of dimensions <code>(N, r)</code></p><p><strong>Arguments</strong></p><ul><li><code>H</code>: H matrix</li><li><code>r</code>: reduced order</li></ul><p><strong>Returns</strong></p><ul><li>extracted <code>H</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L404-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.fidx-Tuple{Any, Any, Any}" href="#LiftAndLearn.fidx-Tuple{Any, Any, Any}"><code>LiftAndLearn.fidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fidx(n::Int, j::Int, k::Int) → Int</code></pre><p>Auxiliary function for the <code>F</code> matrix indexing.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: row dimension of the F matrix</li><li><code>j</code>: row index </li><li><code>k</code>: col index</li></ul><p><strong>Returns</strong></p><ul><li>index corresponding to the <code>F</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L558-L570">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.forwardEuler-Tuple{Function, Function, VecOrMat{T} where T, VecOrMat{T} where T}" href="#LiftAndLearn.forwardEuler-Tuple{Function, Function, VecOrMat{T} where T, VecOrMat{T} where T}"><code>LiftAndLearn.forwardEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forwardEuler(f, g, tdata, IC)
</code></pre><p>Forward euler scheme [dispatch for f(x,u) and u = g(u,t)]</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Xdot = f(x,g(u,t)) right-hand-side of the dynamics</li><li><code>g</code>: Xdot = f(x,g(u,t)) input function g(u,t)</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial conditions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.forwardEuler-Tuple{Function, Matrix{T} where T, VecOrMat{T} where T, VecOrMat{T} where T}" href="#LiftAndLearn.forwardEuler-Tuple{Function, Matrix{T} where T, VecOrMat{T} where T, VecOrMat{T} where T}"><code>LiftAndLearn.forwardEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forwardEuler(f, U, tdata, IC)
</code></pre><p>Forward euler scheme [dispatch for f(x,u) and u-input as U-matrix]</p><p><strong>Arguments</strong></p><ul><li><code>f</code>: Xdot = f(x,U) right-hand-side of the dynamics</li><li><code>U</code>: Xdot = f(x,U) input data U</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial conditions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.forwardEuler-Tuple{Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, VecOrMat{T} where T, VecOrMat{T} where T}" href="#LiftAndLearn.forwardEuler-Tuple{Matrix{T} where T, Matrix{T} where T, Matrix{T} where T, VecOrMat{T} where T, VecOrMat{T} where T}"><code>LiftAndLearn.forwardEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">forwardEuler(A, B, U, tdata, IC)
</code></pre><p>Forward euler scheme integration.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: linear state operator</li><li><code>B</code>: linear input operator</li><li><code>U</code>: input vector/matrix</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial conditions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.getDataMat-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Matrix{T} where T, Dict, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.getDataMat-Tuple{Matrix{T} where T, Union{Matrix{T} where T, LinearAlgebra.Transpose}, Matrix{T} where T, Dict, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.getDataMat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getDataMat(Xhat::Matrix, Xhat_t::Union{Matrix,Transpose}, U::Matrix,
    dims::Dict, options::Abstract_Options) → D</code></pre><p>Get the data matrix for the regression problem</p><p><strong>Arguments</strong></p><ul><li><code>Xhat::Matrix</code>: projected data matrix</li><li><code>Xhat_t::Union{Matrix,Transpose}</code>: projected data matrix (transposed)</li><li><code>U::Matrix</code>: input data matrix</li><li><code>dims::Dict</code>: dictionary including important dimensions</li><li><code>options::Abstract_Options</code>: options for the operator inference set by the user</li></ul><p><strong>Returns</strong></p><ul><li><code>D</code>: data matrix for the regression problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L66-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.inferOp" href="#LiftAndLearn.inferOp"><code>LiftAndLearn.inferOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inferOp(X::Matrix, U::Matrix, Y::VecOrMat, Vn::Matrix,
    options::Abstract_Options, IG::operators=operators()) → op::operators</code></pre><p>Infer the operators without derivative data (dispatch)</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix</code>: state data matrix</li><li><code>U::Matrix</code>: input data matrix</li><li><code>Y::VecOrMat</code>: output data matix</li><li><code>Vn::Matrix</code>: POD basis</li><li><code>options::Abstract_Options</code>: options for the operator inference defined by the user</li><li><code>IG::operators</code>: initial guesses for optimization</li></ul><p><strong>Returns</strong></p><ul><li><code>op::operators</code>: inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L425-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.inferOp" href="#LiftAndLearn.inferOp"><code>LiftAndLearn.inferOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inferOp(X::Matrix, U::Matrix, Y::VecOrMat, Vn::Matrix, R::Matrix,
    options::Abstract_Options, IG::operators=operators()) → op::operators</code></pre><p>Infer the operators with derivative data given</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix</code>: state data matrix</li><li><code>U::Matrix</code>: input data matrix</li><li><code>Y::VecOrMat</code>: output data matix</li><li><code>Vn::Matrix</code>: POD basis</li><li><code>R::Matrix</code>: derivative data matrix</li><li><code>options::Abstract_Options</code>: options for the operator inference defined by the user</li><li><code>IG::operators</code>: initial guesses for optimization</li></ul><p><strong>Returns</strong></p><ul><li><code>op::operators</code>: inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L385-L402">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.inferOp" href="#LiftAndLearn.inferOp"><code>LiftAndLearn.inferOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inferOp(X::Matrix, U::Matrix, Y::VecOrMat, Vn::Matrix,
    full_op::operators, options::Abstract_Options, IG::operators=operators()) → op::operators</code></pre><p>Infer the operators with reprojection method (dispatch)</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix</code>: state data matrix</li><li><code>U::Matrix</code>: input data matrix</li><li><code>Y::VecOrMat</code>: output data matix</li><li><code>Vn::Matrix</code>: POD basis</li><li><code>full_op::operators</code>: full order model operators</li><li><code>options::Abstract_Options</code>: options for the operator inference defined by the user</li><li><code>IG::operators</code>: initial guesses for optimization</li></ul><p><strong>Returns</strong></p><ul><li><code>op::operators</code>: inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L472-L489">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.inferOp" href="#LiftAndLearn.inferOp"><code>LiftAndLearn.inferOp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">inferOp(W::Matrix, U::Matrix, Y::VecOrMat, Vn::Union{Matrix,BlockDiagonal},
    lm::lifting, full_op::operators, options::Abstract_Options, 
    IG::operators=operators()) → op::operators</code></pre><p>Infer the operators for Lift And Learn for reprojected data (dispatch)</p><p><strong>Arguments</strong></p><ul><li><code>W::Matrix</code>: state data matrix</li><li><code>U::Matrix</code>: input data matrix</li><li><code>Y::VecOrMat</code>: output data matix</li><li><code>Vn::Union{Matrix,BlockDiagonal}</code>: POD basis</li><li><code>lm::lifting</code>: struct of the lift map</li><li><code>full_op::operators</code>: full order model operators</li><li><code>options::Abstract_Options</code>: options for the operator inference defined by the user</li><li><code>IG::operators</code>: initial guesses for optimization</li></ul><p><strong>Returns</strong></p><ul><li><code>op::operators</code>: inferred operators</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L514-L533">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.insert2F-Tuple{Any, Any}" href="#LiftAndLearn.insert2F-Tuple{Any, Any}"><code>LiftAndLearn.insert2F</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insertF(Fi::Union{SparseMatrixCSC,VecOrMat}, N::Int) → F</code></pre><p>Inserting values into the <code>F</code> matrix for higher dimensions</p><p><strong>Arguments</strong></p><ul><li><code>Fi</code>: F matrix to insert</li><li><code>N</code>: the larger order</li></ul><p><strong>Returns</strong></p><ul><li>inserted <code>F</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L356-L367">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.insert2H-Tuple{Any, Any}" href="#LiftAndLearn.insert2H-Tuple{Any, Any}"><code>LiftAndLearn.insert2H</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insertH(Hi::Union{SparseMatrixCSC,VecOrMat}, N::Int) → H</code></pre><p>Inserting values into the <code>H</code> matrix for higher dimensions</p><p><strong>Arguments</strong></p><ul><li><code>Hi</code>: H matrix to insert</li><li><code>N</code>: the larger order</li></ul><p><strong>Returns</strong></p><ul><li>inserted <code>H</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L430-L441">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.insert2bilin-Tuple{Any, Any, Any}" href="#LiftAndLearn.insert2bilin-Tuple{Any, Any, Any}"><code>LiftAndLearn.insert2bilin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert2bilin(X::Union{SparseMatrixCSC,VecOrMat}, N::Int, p::Int) → BL</code></pre><p>Inserting the values into the bilinear matrix (<code>N</code>) for higher dimensions</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: bilinear matrix to insert</li><li><code>N</code>: the larger order</li></ul><p><strong>Returns</strong></p><ul><li>Inserted bilinear matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L453-L464">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.insert2randF-Tuple{Any, Any}" href="#LiftAndLearn.insert2randF-Tuple{Any, Any}"><code>LiftAndLearn.insert2randF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">insert2randF(Fi::Union{SparseMatrixCSC,VecOrMat}, N::Int) → F</code></pre><p>Inserting values into the <code>F</code> matrix for higher dimensions</p><p><strong>Arguments</strong></p><ul><li><code>Fi</code>: F matrix to insert</li><li><code>N</code>: the larger order</li></ul><p><strong>Returns</strong></p><ul><li>inserted <code>F</code> matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L380-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.intrusiveMR-Tuple{operators, AbstractArray, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.intrusiveMR-Tuple{operators, AbstractArray, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.intrusiveMR</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intrusiveMR(op, Vr, options)
</code></pre><p>Perform intrusive model reduction using Proper Orthogonal Decomposition (POD)</p><p><strong>Arguments</strong></p><ul><li><code>op</code>: operators of the target system (A, B, C, F/H, N, K)</li><li><code>Vr</code>: POD basis</li><li><code>options</code>: options for the operator inference</li></ul><p><strong>Return</strong></p><ul><li><code>op_new</code>: new operator projected onto the basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/intrusiveROM.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.invec-Tuple{AbstractArray, Int64, Int64}" href="#LiftAndLearn.invec-Tuple{AbstractArray, Int64, Int64}"><code>LiftAndLearn.invec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">invec(r::AbstractArray, m::Int, n::Int) → r</code></pre><p>Inverse vectorization.</p><p><strong>Arguments</strong></p><ul><li><code>r::AbstractArray</code>: the input vector</li><li><code>m::Int</code>: the row dimension</li><li><code>n::Int</code>: the column dimension</li></ul><p><strong>Returns</strong></p><ul><li>the inverse vectorized matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L476-L488">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.kronMatStates-Tuple{Any}" href="#LiftAndLearn.kronMatStates-Tuple{Any}"><code>LiftAndLearn.kronMatStates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kronMatStates(Xmat::Union{SparseMatrixCSC,VecOrMat}) → Xkron</code></pre><p>Generate the kronecker product state values (corresponding to the <code>H</code> matrix) for  a matrix form state data</p><p><strong>Arguments</strong></p><ul><li><code>Xmat</code>: state snapshot matrix</li></ul><p><strong>Returns</strong></p><ul><li>kronecker product state snapshot matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L308-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.liftedBasis-Tuple{Matrix{T} where T, Real, Integer, Vector{T} where T}" href="#LiftAndLearn.liftedBasis-Tuple{Matrix{T} where T, Real, Integer, Vector{T} where T}"><code>LiftAndLearn.liftedBasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">liftedBasis(W, Nl, gp, ro) → Vr</code></pre><p>Create the block-diagonal POD basis for the new lifted system data</p><p><strong>Arguments</strong></p><ul><li><code>w</code>: lifted data matrix</li><li><code>Nl</code>: number of variables of the lifted state dynamics</li><li><code>gp</code>: number of grid points for each variable</li><li><code>ro</code>: vector of the reduced orders for each basis</li></ul><p><strong>Return</strong></p><ul><li><code>Vr</code>: block diagonal POD basis</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/lift.jl#L56-L70">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.nommat-Tuple{Integer, Integer}" href="#LiftAndLearn.nommat-Tuple{Integer, Integer}"><code>LiftAndLearn.nommat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nommat(m::Integer, n::Integer) → N</code></pre><p>Create symmetric commutation matrix <code>N</code> of dimension <code>m x n</code> <sup class="footnote-reference"><a id="citeref-magnus1980" href="#footnote-magnus1980">[magnus1980]</a></sup>.</p><p><strong>Arguments</strong></p><ul><li><code>m::Integer</code>: row dimension of the commutation matrix</li><li><code>n::Integer</code>: column dimension of the commutation matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>N</code>: symmetric commutation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L161-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.nommat-Tuple{Integer}" href="#LiftAndLearn.nommat-Tuple{Integer}"><code>LiftAndLearn.nommat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nommat(m::Integer) → N</code></pre><p>Dispatch for the symmetric commutation matrix of dimensions (m, m)</p><p><strong>Arguments</strong></p><ul><li><code>m::Integer</code>: row and column dimension of the commutation matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>N</code>: symmetric commutation matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L179-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.reproject-Tuple{Matrix{T} where T, Union{BlockDiagonals.BlockDiagonal, VecOrMat{T} where T}, VecOrMat{T} where T, Dict, lifting, operators, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.reproject-Tuple{Matrix{T} where T, Union{BlockDiagonals.BlockDiagonal, VecOrMat{T} where T}, VecOrMat{T} where T, Dict, lifting, operators, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.reproject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inferOp(W::Matrix, U::Matrix, Y::VecOrMat, Vn::Union{Matrix,BlockDiagonal},
    lm::lifting, options::Abstract_Options, IG::operators=operators()) → op::operators</code></pre><p>Reprojecting the lifted data</p><p><strong>Arguments</strong></p><ul><li><code>Xhat::Matrix</code>: state data matrix projected onto the basis</li><li><code>V::Union{VecOrMat,BlockDiagonal}</code>: POD basis</li><li><code>U::VecOrMat</code>: input data matrix</li><li><code>dims::Dict</code>: dictionary including important dimensions</li><li><code>lm::lifting</code>: struct of the lift map</li><li><code>op::operators</code>: full order model operators</li><li><code>options::Abstract_Options</code>: options for the operator inference defined by the user</li></ul><p><strong>Returns</strong></p><ul><li><code>Rhat::Matrix</code>: R matrix (transposed) for the regression problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L628-L645">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.reproject-Tuple{Matrix{T} where T, Union{BlockDiagonals.BlockDiagonal, VecOrMat{T} where T}, VecOrMat{T} where T, Dict, operators, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.reproject-Tuple{Matrix{T} where T, Union{BlockDiagonals.BlockDiagonal, VecOrMat{T} where T}, VecOrMat{T} where T, Dict, operators, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.reproject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inferOp(W::Matrix, U::Matrix, Y::VecOrMat, Vn::Union{Matrix,BlockDiagonal},
    lm::lifting, options::Abstract_Options, IG::operators=operators()) → op::operators</code></pre><p>Reprojecting the data to minimize the error affected by the missing orders of the POD basis</p><p><strong>Arguments</strong></p><ul><li><code>Xhat::Matrix</code>: state data matrix projected onto the basis</li><li><code>V::Union{VecOrMat,BlockDiagonal}</code>: POD basis</li><li><code>U::VecOrMat</code>: input data matrix</li><li><code>dims::Dict</code>: dictionary including important dimensions</li><li><code>op::operators</code>: full order model operators</li><li><code>options::Abstract_Options</code>: options for the operator inference defined by the user</li></ul><p><strong>Return</strong></p><ul><li><code>Rhat::Matrix</code>: R matrix (transposed) for the regression problem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L571-L587">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.run_optimizer" href="#LiftAndLearn.run_optimizer"><code>LiftAndLearn.run_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run_optimizer(D::AbstractArray, Rt::AbstractArray, Y::AbstractArray,
    Xhat_t::AbstractArray, dims::Dict, options::Abstract_Options,
    IG::operators=operators()) → op::operators</code></pre><p>Run the optimizer of choice.</p><p><strong>Arguments</strong></p><ul><li><code>D::AbstractArray</code>: data matrix</li><li><code>Rt::AbstractArray</code>: derivative data matrix (transposed)</li><li><code>Y::AbstractArray</code>: output data matrix</li><li><code>Xhat_t::AbstractArray</code>: projected data matrix (transposed)</li><li><code>dims::Dict</code>: dictionary including important dimensions</li><li><code>options::Abstract_Options</code>: options for the operator inference set by the user</li><li><code>IG::operators</code>: initial guesses for optimization</li></ul><p><strong>Returns</strong></p><ul><li><code>op::operators</code>: All learned operators </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L325-L343">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.semiImplicitEuler-NTuple{6, Any}" href="#LiftAndLearn.semiImplicitEuler-NTuple{6, Any}"><code>LiftAndLearn.semiImplicitEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semiImplicitEuler(A, B, F, U, tdata, IC)
</code></pre><p>Semi-Implicit Euler scheme</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: linear state operator</li><li><code>B</code>: linear input operator</li><li><code>F</code>: quadratic state operator</li><li><code>U</code>: input data</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial condtions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.semiImplicitEuler-NTuple{7, Any}" href="#LiftAndLearn.semiImplicitEuler-NTuple{7, Any}"><code>LiftAndLearn.semiImplicitEuler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">semiImplicitEuler(A, B, F_or_H, U, tdata, IC, options)
</code></pre><p>Semi-Implicit Euler scheme (dispatch)</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: linear state operator</li><li><code>B</code>: linear input operator</li><li><code>F_or_H</code>: quadratic state operator (F or H)</li><li><code>U</code>: input data</li><li><code>tdata</code>: time data</li><li><code>IC</code>: initial condtions</li></ul><p><strong>Return</strong></p><ul><li><code>states</code>: integrated states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/integrator.jl#L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.squareMatStates-Tuple{Any}" href="#LiftAndLearn.squareMatStates-Tuple{Any}"><code>LiftAndLearn.squareMatStates</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">squareMatStates(Xmat::Union{SparseMatrixCSC,VecOrMat}) → Xsq</code></pre><p>Generate the <code>x^[2]</code> squared state values (corresponding to the <code>F</code> matrix) for a  snapshot data matrix</p><p><strong>Arguments</strong></p><ul><li><code>Xmat</code>: state snapshot matrix</li></ul><p><strong>Returns</strong></p><ul><li>squared state snapshot matrix </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L287-L298">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.tikhonov-Tuple{AbstractArray, AbstractArray, AbstractMatrix{T} where T, Real}" href="#LiftAndLearn.tikhonov-Tuple{AbstractArray, AbstractArray, AbstractMatrix{T} where T, Real}"><code>LiftAndLearn.tikhonov</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tikhonov(b::AbstractArray, A::AbstractArray, Γ::AbstractMatrix, tol::Real;
    flag::Bool=false) → x</code></pre><p>Tikhonov regression</p><p><strong>Arguments</strong></p><ul><li><code>b::AbstractArray</code>: right hand side of the regression problem</li><li><code>A::AbstractArray</code>: left hand side of the regression problem</li><li><code>Γ::AbstractMatrix</code>: Tikhonov matrix</li><li><code>tol::Real</code>: tolerance for the singular values</li><li><code>flag::Bool</code>: flag for the tolerance</li></ul><p><strong>Returns</strong></p><ul><li>regression solution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L145-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.tikhonovMatrix!-Tuple{AbstractArray, Dict, LiftAndLearn.Abstract_Options}" href="#LiftAndLearn.tikhonovMatrix!-Tuple{AbstractArray, Dict, LiftAndLearn.Abstract_Options}"><code>LiftAndLearn.tikhonovMatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tikhonovMatrix!(Γ::AbstractArray, dims::Dict, options::Abstract_Options)</code></pre><p>Construct the Tikhonov matrix</p><p><strong>Arguments</strong></p><ul><li><code>Γ::AbstractArray</code>: Tikhonov matrix (pass by reference)</li><li><code>dims::Dict</code>: dictionary including important dimensions</li><li><code>options::Abstract_Options</code>: options for the operator inference set by the user</li></ul><p><strong>Returns</strong></p><ul><li><code>Γ</code>: Tikhonov matrix (pass by reference)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/learn.jl#L183-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.vech-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T" href="#LiftAndLearn.vech-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T"><code>LiftAndLearn.vech</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vech(A::AbstractMatrix{T}) → v</code></pre><p>Half-vectorization operation. For example half-vectorzation of</p><p class="math-container">\[A = \begin{bmatrix}
    a_{11} &amp; a_{12}  \\
    a_{21} &amp; a_{22}
\end{bmatrix}\]</p><p>becomes</p><p class="math-container">\[v = \begin{bmatrix}
    a_{11} \\
    a_{21} \\
    a_{22}
\end{bmatrix}\]</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: matrix to half-vectorize</li></ul><p><strong>Returns</strong></p><ul><li><code>v</code>: half-vectorized form</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/4441e2eb44ac570d7014aaf3894ee3d80e6fd8aa/src/utils.jl#L193-L217">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/KS/">« KS</a><a class="docs-footer-nextpage" href="../paper/">Paper Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Sunday 17 December 2023 15:39">Sunday 17 December 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
