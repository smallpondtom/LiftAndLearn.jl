<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lyapunov Exponents · LiftAndLearn.jl</title><meta name="title" content="Lyapunov Exponents · LiftAndLearn.jl"/><meta property="og:title" content="Lyapunov Exponents · LiftAndLearn.jl"/><meta property="twitter:title" content="Lyapunov Exponents · LiftAndLearn.jl"/><meta name="description" content="Documentation for LiftAndLearn.jl."/><meta property="og:description" content="Documentation for LiftAndLearn.jl."/><meta property="twitter:description" content="Documentation for LiftAndLearn.jl."/><script async src="https://www.googletagmanager.com/gtag/js?id=G-B2FEJZ9J99"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-B2FEJZ9J99', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img class="docs-light-only" src="../../../assets/logo.png" alt="LiftAndLearn.jl logo"/><img class="docs-dark-only" src="../../../assets/logo-dark.png" alt="LiftAndLearn.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">LiftAndLearn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../Utilities/">Utilities</a></li><li><a class="tocitem" href="../../Options/">Options</a></li><li><a class="tocitem" href="../../Lift/">Lift</a></li><li><a class="tocitem" href="../../Intrusive/">Intrusive</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Non-Intrusive</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../nonintrusive/LS/">Standard OpInf</a></li><li><a class="tocitem" href="../../nonintrusive/LnL/">Lift And Learn</a></li><li><a class="tocitem" href="../../nonintrusive/EPOpInf/">Energy Preserving</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-6" type="checkbox" checked/><label class="tocitem" for="menuitem-2-6"><span class="docs-label">ChaosGizmo</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../chaosgizmo/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Lyapunov Exponents</a><ul class="internal"><li><a class="tocitem" href="#Lyapunov-Exponent"><span>Lyapunov Exponent</span></a></li><li><a class="tocitem" href="#Kaplan-Yorke-dimension"><span>Kaplan-Yorke dimension</span></a></li><li><a class="tocitem" href="#Implementation-Details"><span>Implementation Details</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../../../models/Heat1D/">Heat1D</a></li><li><a class="tocitem" href="../../../models/Burgers/">Burgers</a></li><li><a class="tocitem" href="../../../models/FHN/">FHN</a></li><li><a class="tocitem" href="../../../models/KS/">KS</a></li></ul></li><li><a class="tocitem" href="../../../api/">API Reference</a></li><li><a class="tocitem" href="../../../paper/">Paper Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li><a class="is-disabled">ChaosGizmo</a></li><li class="is-active"><a href>Lyapunov Exponents</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lyapunov Exponents</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/smallpondtom/LiftAndLearn.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/https://github.com/smallpondtom/LiftAndLearn.jl/docs/src/manual/ChaosGizmo/lyap_exp.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="LyapunovExponent.jl-Documentation"><a class="docs-heading-anchor" href="#LyapunovExponent.jl-Documentation">LyapunovExponent.jl Documentation</a><a id="LyapunovExponent.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#LyapunovExponent.jl-Documentation" title="Permalink"></a></h1><p>This file contains the implementation of functions related to the computation of Lyapunov Exponents and Kaplan-Yorke dimension.</p><h2 id="Lyapunov-Exponent"><a class="docs-heading-anchor" href="#Lyapunov-Exponent">Lyapunov Exponent</a><a id="Lyapunov-Exponent-1"></a><a class="docs-heading-anchor-permalink" href="#Lyapunov-Exponent" title="Permalink"></a></h2><p>We implement two different algorithms to compute the Lyapunov exponent. The first implementation <code>lyapunovExponent</code> requires numerical integration of the model with unperturbed initial conditions and perturbed initial conditions to compute the Lyapunov exponent. The second implementation <code>lyapunovExponentJacobian</code> leverages the tangent map or Jacobian. </p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.lyapunovExponent" href="#LiftAndLearn.ChaosGizmo.lyapunovExponent"><code>LiftAndLearn.ChaosGizmo.lyapunovExponent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lyapunovExponent(ops::operators, integrator::Function, ic::AbstractArray, 
        options::LE_options, params...) → λ::Vector or (λ::Vector, λ_all::Matrix)</code></pre><p>Compute the Lyapunov exponents of a dynamical system using the algorirhtm in <sup class="footnote-reference"><a id="citeref-edson2019" href="#footnote-edson2019">[edson2019]</a></sup> which uses the algorithm from <sup class="footnote-reference"><a id="citeref-benettin1980" href="#footnote-benettin1980">[benettin1980]</a></sup> and <sup class="footnote-reference"><a id="citeref-shimada1979" href="#footnote-shimada1979">[shimada1979]</a></sup> to compute them.</p><p><strong>Arguments</strong></p><ul><li><code>ops::operators</code>: operators for the full model</li><li><code>integrator::Function</code>: integrator for the model</li><li><code>ic::AbstractArray</code>: initial condition</li><li><code>options::LE_options</code>: options for the algorithm</li><li><code>params...</code>: keyword arguments for the integrator</li></ul><p><strong>Returns</strong></p><ul><li><code>λ::Vector</code>: the Lyapunov exponents</li><li><code>λ_all::Matrix</code>: all Lyapunov exponents if <code>options.history</code> is <code>true</code></li></ul><p><strong>Integrator function format</strong></p><p>The integrator function must be in the form of <code>integrator(ops, tspan, ic)</code> where <code>ops</code> is the operator struct, <code>tspan</code> is the time span to integrate over, and <code>ic</code> is the initial condition. The integrator must return the solution at the final time. And the integrator can have additional parameters as keyword arguments <code>params...</code>.</p><p>Example integrator function for the Lorenz system using the 4th order Runge-Kutta method:</p><pre><code class="language-julia hljs">function lorenz_integrator(ops::LnL.operators, tspan::AbstractArray, IC::Array; params...)
    K = length(tspan)
    N = size(IC,1)
    f = let A = ops.A, H = ops.H
        (x, t) -&gt; A*x + H*kron(x,x)
    end
    xk = zeros(N,K)
    xk[:,1] = IC

    for k in 2:K
        timestep = tspan[k] - tspan[k-1]
        k1 = f(xk[:,k-1], tspan[k-1])
        k2 = f(xk[:,k-1] + 0.5 * timestep * k1, tspan[k-1] + 0.5 * timestep)
        k3 = f(xk[:,k-1] + 0.5 * timestep * k2, tspan[k-1] + 0.5 * timestep)
        k4 = f(xk[:,k-1] + timestep * k3, tspan[k-1] + timestep)
        xk[:,k] = xk[:,k-1] + (timestep / 6.0) * (k1 + 2*k2 + 2*k3 + k4)
    end
    return xk
end</code></pre><p><strong>References</strong></p><p><sup class="footnote-reference"><a id="citeref-edson2019" href="#footnote-edson2019">[edson2019]</a></sup> R. A. Edson, J. E. Bunder, T. W. Mattner, and A. J. Roberts,  “Lyapunov Exponents of the Kuramoto–Sivashinsky PDE,” The ANZIAM Journal, vol. 61, no. 3, pp. 270–285, Jul. 2019, doi: 10.1017/S1446181119000105.</p><p><sup class="footnote-reference"><a id="citeref-benettin1980" href="#footnote-benettin1980">[benettin1980]</a></sup> G. Benettin, L. Galgani, A. Giorgilli, and J.-M. Strelcyn,  “Lyapunov Characteristic Exponents for smooth dynamical systems and for hamiltonian systems; a method for computing all of them. Part 1: Theory,” Meccanica,  vol. 15, no. 1, pp. 9–20, Mar. 1980, doi: 10.1007/BF02128236.</p><p><sup class="footnote-reference"><a id="citeref-shimada1979" href="#footnote-shimada1979">[shimada1979]</a></sup> [1] I. Shimada and T. Nagashima, “A Numerical Approach to Ergodic Problem of Dissipative Dynamical Systems,” Progress of Theoretical Physics,  vol. 61, no. 6, pp. 1605–1616, Jun. 1979, doi: 10.1143/PTP.61.1605.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L77-L137">source</a></section><section><div><pre><code class="language-julia hljs">lyapunovExponent(ops::operators, integrator::Function, Vr::AbstractArray, 
    ic::AbstractArray, options::LE_options, params...) → λ::Vector or (λ::Vector, λ_all::Matrix)</code></pre><p>Compute the Lyapunov exponents of a dynamical system using the algorirhtm in <sup class="footnote-reference"><a id="citeref-edson2019" href="#footnote-edson2019">[edson2019]</a></sup> for the reduced model. This is a dispatched function for the case when the reduced model is used.</p><p><strong>Arguments</strong></p><ul><li><code>model::Abstract_Models</code>: the dynamical model</li><li><code>ops::operators</code>: operators for the reduced model</li><li><code>integrator::Function</code>: integrator for the model</li><li><code>Vr::AbstractArray</code>: basis for the reduced model</li><li><code>ic::AbstractArray</code>: initial condition</li><li><code>options::LE_options</code>: options for the algorithm</li><li><code>params...</code>: keyword arguments for the integrator</li></ul><p><strong>Returns</strong></p><ul><li><code>λ::Vector</code>: the Lyapunov exponents</li><li><code>λ_all::Matrix</code>: all Lyapunov exponents if <code>options.history</code> is <code>true</code></li></ul><p><strong>Integrator function format</strong></p><p>The integrator function must be in the form of <code>integrator(ops, tspan, ic)</code> where <code>ops</code> is the operator struct, <code>tspan</code> is the time span to integrate over, and <code>ic</code> is the initial condition. The integrator must return the solution at the final time. And the integrator can have additional parameters as keyword arguments <code>params...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L212-L236">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.lyapunovExponentJacobian" href="#LiftAndLearn.ChaosGizmo.lyapunovExponentJacobian"><code>LiftAndLearn.ChaosGizmo.lyapunovExponentJacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lyapunovExponentJacobian(ops::operators, integrator::Function, jacobian::Function, 
    ic::AbstractArray, options::LE_options, params...) → λ::Vector or (λ::Vector, λ_all::Matrix)</code></pre><p>Compute the Lyapunov exponents of the full order dynamical system using the Jacobian of the system.  Refer to <a href="#References">References</a> for more details.</p><p><strong>Arguments</strong></p><ul><li><code>ops::operators</code>: operators for the full/reduced model</li><li><code>integrator::Function</code>: integrator for the full/reduced model</li><li><code>jacobian::Function</code>: Jacobian of the system</li><li><code>ic::AbstractArray</code>: initial condition</li><li><code>options::LE_options</code>: options for the algorithm</li><li><code>params...</code>: keyword arguments for the integrator</li></ul><p><strong>Returns</strong></p><ul><li><code>λ::Vector</code>: the Lyapunov exponents</li><li><code>λ_all::Matrix</code>: all Lyapunov exponents if <code>options.history</code> is <code>true</code></li></ul><p><strong>Integrator function format</strong></p><p>The integrator function must be in the form of <code>integrator(ops, tspan, ic)</code> where <code>ops</code> is the operator struct, <code>tspan</code> is the time span to integrate over, and <code>ic</code> is the initial condition. The integrator must return the solution at the final time. And the integrator can have additional parameters as keyword arguments <code>params...</code>.</p><p><strong>Function to generate the Jacobian</strong></p><p>The Jacobian function must be in the form of <code>jacobian(ops, x)</code> where <code>ops</code> is the operator struct and <code>x</code> is the state. This Jacobian matrix constructs the Linear Tangent Map (LTM) of the system. The Jacobian for a linear-quadratic system </p><p class="math-container">\[\dot{\mathbf{x}} = \mathbf{Ax} + \mathbf{H}(\mathbf{x} \otimes \mathbf{x})\]</p><p>is for exmaple</p><pre><code class="language-julia hljs">function jacobian(ops, x)
    A = ops.A
    H = ops.H
    return A + H * kron(1.0I(n), x) + H * kron(x, 1.0I(n))
end</code></pre><p><strong>References</strong></p><ul><li><a href="https://github.com/ni-sha-c/Lyapunov">GitHub code</a> by <code>ni-sha-c</code> </li><li><a href="https://github.com/ThomasSavary08/Lyapynov">GitHub code</a> by <code>ThomasSavary08</code></li><li>P. V. Kuptsov and U. Parlitz, “Theory and computation of covariant Lyapunov vectors,” arXiv, 2011, doi: 10.48550/ARXIV.1105.5228.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L354-L400">source</a></section><section><div><pre><code class="language-julia hljs">lyapunovExponentJacobian(ops::operators, integrator::Function, jacobian::Function, Vr::AbstractArray, 
    ic::AbstractArray, options::LE_options, params...) → λ::Vector or (λ::Vector, λ_all::Matrix)</code></pre><p>Compute the Lyapunov exponents of a reduced order dynamical system using the Jacobian of the system.  Refer to <a href="#References">References</a> for more details.</p><p><strong>Arguments</strong></p><ul><li><code>ops::operators</code>: operators for the full/reduced model</li><li><code>integrator::Function</code>: integrator for the full/reduced model</li><li><code>jacobian::Function</code>: Jacobian of the system</li><li><code>Vr::AbstractArray</code>: basis for the reduced model</li><li><code>ic::AbstractArray</code>: initial condition</li><li><code>options::LE_options</code>: options for the algorithm</li><li><code>params...</code>: keyword arguments for the integrator</li></ul><p><strong>Returns</strong></p><ul><li><code>λ::Vector</code>: the Lyapunov exponents</li><li><code>λ_all::Matrix</code>: all Lyapunov exponents if <code>options.history</code> is <code>true</code></li></ul><p><strong>Integrator function format</strong></p><p>The integrator function must be in the form of <code>integrator(ops, tspan, ic)</code> where <code>ops</code> is the operator struct, <code>tspan</code> is the time span to integrate over, and <code>ic</code> is the initial condition. The integrator must return the solution at the final time. And the integrator can have additional parameters as keyword arguments <code>params...</code>.</p><p><strong>Function to generate the Jacobian</strong></p><p>The Jacobian function must be in the form of <code>jacobian(ops, x)</code> where <code>ops</code> is the operator struct and <code>x</code> is the state. This Jacobian matrix constructs the Linear Tangent Map (LTM) of the system. The Jacobian for a linear-quadratic system </p><p class="math-container">\[\dot{\mathbf{x}} = \mathbf{Ax} + \mathbf{H}(\mathbf{x} \otimes \mathbf{x})\]</p><p>is for exmaple</p><pre><code class="language-julia hljs">function jacobian(ops, x)
    A = ops.A
    H = ops.H
    return A + H * kron(1.0I(n), x) + H * kron(x, 1.0I(n))
end</code></pre><p><strong>References</strong></p><ul><li><a href="https://github.com/ni-sha-c/Lyapunov">GitHub code</a> by <code>ni-sha-c</code> </li><li><a href="https://github.com/ThomasSavary08/Lyapynov">GitHub code</a> by <code>ThomasSavary08</code></li><li>P. V. Kuptsov and U. Parlitz, “Theory and computation of covariant Lyapunov vectors,” arXiv, 2011, doi: 10.48550/ARXIV.1105.5228.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L476-L523">source</a></section></article><h2 id="Kaplan-Yorke-dimension"><a class="docs-heading-anchor" href="#Kaplan-Yorke-dimension">Kaplan-Yorke dimension</a><a id="Kaplan-Yorke-dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Kaplan-Yorke-dimension" title="Permalink"></a></h2><p>The Kaplan-Yorke dimension represents the effective dimension of the chaotic attractor. For more details see this <a href="https://www.wikiwand.com/en/Kaplan%E2%80%93Yorke_conjecture">explanation</a>. In ChaosGizmo, the Kaplan-Yorke dimension is computed for given Lyapunov exponents.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.kaplanYorkeDim" href="#LiftAndLearn.ChaosGizmo.kaplanYorkeDim"><code>LiftAndLearn.ChaosGizmo.kaplanYorkeDim</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kaplanYorkeDim(λs::AbstractVector; sorted::Bool=true) → Dky::Float64</code></pre><p>Compute the Kaplan-Yorke dimension from the Lyapunov exponents.</p><p><strong>Arguments</strong></p><ul><li><code>λs::AbstractVector{&lt;:Real}</code>: the Lyapunov exponents</li><li><code>sorted::Bool</code>: whether the Lyapunov exponents are sorted in descending order</li></ul><p><strong>Returns</strong></p><ul><li><code>Float64</code>: the Kaplan-Yorke dimension</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using LiftAndLearn.ChaosGizmo

julia&gt; CG = LiftAndLearn.ChaosGizmo

julia&gt; lyapunovSpectrum = [0.5, 0.1, -0.2, -0.4]  # Example spectrum

julia&gt; kyDimension = CG.kaplanYorkeDim(lyapunovSpectrum)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L608-L631">source</a></section></article><h2 id="Implementation-Details"><a class="docs-heading-anchor" href="#Implementation-Details">Implementation Details</a><a id="Implementation-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-Details" title="Permalink"></a></h2><h3 id="Integration-step-of-the-tangent-map"><a class="docs-heading-anchor" href="#Integration-step-of-the-tangent-map">Integration step of the tangent map</a><a id="Integration-step-of-the-tangent-map-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-step-of-the-tangent-map" title="Permalink"></a></h3><p>To integrate the tangent map/Jacobian further in time we employ multiple integration schemes ranging from Euler method, 4th order Runge-Kutta, and strong stability preserving Runge-Kutta (SSPRK3).</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.EULER" href="#LiftAndLearn.ChaosGizmo.EULER"><code>LiftAndLearn.ChaosGizmo.EULER</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">EULER(J, Q, dt) → Qnew</code></pre><p>Euler method for the perturbation integrator.</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix</code>: Jacobian of the system</li><li><code>Q::AbstractArray</code>: perturbation state</li><li><code>dt::Real</code>: timestep</li></ul><p><strong>Returns</strong></p><ul><li><code>Qnew::AbstractArray</code>: updated perturbation state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/integrators.jl#L118-L130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.RK2" href="#LiftAndLearn.ChaosGizmo.RK2"><code>LiftAndLearn.ChaosGizmo.RK2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RK2(J, Q, dt) → Qnew</code></pre><p>2nd order Runge-Kutta method for the perturbation integrator.</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix</code>: Jacobian of the system</li><li><code>Q::AbstractArray</code>: perturbation state</li><li><code>dt::Real</code>: timestep</li></ul><p><strong>Returns</strong></p><ul><li><code>Qnew::AbstractArray</code>: updated perturbation state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/integrators.jl#L26-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.RK4" href="#LiftAndLearn.ChaosGizmo.RK4"><code>LiftAndLearn.ChaosGizmo.RK4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RK4(J, Q, dt) → Qnew</code></pre><p>4th order Runge-Kutta method for the perturbation integrator.</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix</code>: Jacobian of the system</li><li><code>Q::AbstractArray</code>: perturbation state</li><li><code>dt::Real</code>: timestep</li></ul><p><strong>Returns</strong></p><ul><li><code>Qnew::AbstractArray</code>: updated perturbation state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/integrators.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.RALSTON4" href="#LiftAndLearn.ChaosGizmo.RALSTON4"><code>LiftAndLearn.ChaosGizmo.RALSTON4</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">RALSTON4(J, Q, dt) → Qnew</code></pre><p>Ralston&#39;s fourth-order method for the perturbation integrator.</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix</code>: Jacobian of the system</li><li><code>Q::AbstractArray</code>: perturbation state</li><li><code>dt::Real</code>: timestep</li></ul><p><strong>Returns</strong></p><ul><li><code>Qnew::AbstractArray</code>: updated perturbation state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/integrators.jl#L79-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.SSPRK3" href="#LiftAndLearn.ChaosGizmo.SSPRK3"><code>LiftAndLearn.ChaosGizmo.SSPRK3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">SSPRK3(J, Q, dt) → Qnew</code></pre><p>3rd order Strong Stability Preserving Runge-Kutta method for the perturbation integrator.</p><p><strong>Arguments</strong></p><ul><li><code>J::AbstractMatrix</code>: Jacobian of the system</li><li><code>Q::AbstractArray</code>: perturbation state</li><li><code>dt::Real</code>: timestep</li></ul><p><strong>Returns</strong></p><ul><li><code>Qnew::AbstractArray</code>: updated perturbation state</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/integrators.jl#L49-L61">source</a></section></article><h3 id="Adjusting-the-QR-decomposition"><a class="docs-heading-anchor" href="#Adjusting-the-QR-decomposition">Adjusting the QR decomposition</a><a id="Adjusting-the-QR-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Adjusting-the-QR-decomposition" title="Permalink"></a></h3><p>In every step of computing the Lyapunov exponent, it is necessary to reorthogonalize the tangent map. And, in this process we must adjust the signs in the <code>Q</code> and <code>R</code> matrices using the following routine:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.posDiag_QR!" href="#LiftAndLearn.ChaosGizmo.posDiag_QR!"><code>LiftAndLearn.ChaosGizmo.posDiag_QR!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">posDiag_QR!(Q::AbstractMatrix, R::AbstractMatrix)</code></pre><p>Make sure the diagonal of the R matrix is positive.</p><p><strong>Arguments</strong></p><ul><li><code>Q::AbstractMatrix</code>: orthogonal directions</li><li><code>R::AbstractMatrix</code>: upper triangular matrix</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L329-L340">source</a></section></article><h3 id="Options-for-Lyapunov-exponent-computation"><a class="docs-heading-anchor" href="#Options-for-Lyapunov-exponent-computation">Options for Lyapunov exponent computation</a><a id="Options-for-Lyapunov-exponent-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Options-for-Lyapunov-exponent-computation" title="Permalink"></a></h3><p>To compute the Lyapunov exponents, the user must define the <code>LE_options</code> with necessary parameters. It is crucial to tune the parameters based on your system at hand.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LiftAndLearn.ChaosGizmo.LE_options" href="#LiftAndLearn.ChaosGizmo.LE_options"><code>LiftAndLearn.ChaosGizmo.LE_options</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LE_options</code></pre><p>Options for Lypuanov exponents.</p><p><strong>Fields</strong></p><ul><li><code>m::Integer</code>: the number of the most exponents to compute</li><li><code>τ::Real</code>: time to simulate the system before computing exponents</li><li><code>Δt::Real</code>: timestep for the integrator</li><li><code>Δτ::Real</code>: timestep for the integrator (before computing exponents)</li><li><code>T::Real</code>: time between reorthogonalization steps</li><li><code>N::Integer</code>: the total number of reorthogonalization steps</li><li><code>ϵ::Real</code>: perturbation magnitude</li><li><code>verbose::Bool</code>: print progress to stdout</li><li><code>history::Bool</code>: return all LEs</li><li><code>pert_integrator::Function</code>: integrator for the perturbed system</li></ul><p><strong>Default values</strong></p><ul><li><code>m = 1</code></li><li><code>τ = 1000</code></li><li><code>Δt = 1e-2</code></li><li><code>Δτ = Δt</code></li><li><code>T = Δt</code></li><li><code>N = 1000</code></li><li><code>ϵ = 1e-6</code></li><li><code>verbose = false</code></li><li><code>history = false</code></li><li><code>pert_integrator = nothing</code></li></ul><p><strong>Perturbation integrator</strong></p><p>The perturbation integrator must be in the form of <code>integrator(J, Q, dt)</code> where <code>J</code> is the Jacobian of the system, <code>Q</code> is the perturbation state, and <code>dt</code> is the timestep. The integrator must return the updated perturbation state. The default integrator is the 4th order Runge-Kutta method:&#39;</p><pre><code class="language-julia hljs">function RK4(J, Q, dt)
    # RK4 steps
    k1 = J * Q
    k2 = J * (Q + 0.5*dt*k1)
    k3 = J * (Q + 0.5*dt*k2)
    k4 = J * (Q + dt*k3)
    # Update the perturbation state
    Qnew = Q + (dt/6) * (k1 + 2*k2 + 2*k3 + k4)
    return Qnew
end</code></pre><p>You can select the following explicit method integrators available in the ChaosGizmo submodule:</p><ul><li><code>EULER(J, Q, dt)</code>: Euler method</li><li><code>RK2(J, Q, dt)</code>: 2nd order Runge-Kutta method</li><li><code>RK4(J, Q, dt)</code>: 4th order Runge-Kutta method</li><li><code>SSPRK3(J, Q, dt)</code>: 3rd order Strong Stability Preserving Runge-Kutta method</li><li><code>RALSTON4(J, Q, dt)</code>: Ralston&#39;s fourth-order method</li></ul><p><strong>Note</strong></p><p>If you are using the Jacobian/Linear Tangent Map (LTM) method, T should be set equal to Δt (i.e. Δt = T) or T = 2*Δt.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/smallpondtom/LiftAndLearn.jl/blob/ddfaa48c802dad55dbc5dd701132b85b9e100f47/src/ChaosGizmo/LyapunovExponent.jl#L1">source</a></section></article><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>We use a 9-dimensional Lorenz system to analyze the Lyapunov exponents and Kaplan-Yorke dimension of a reduced model. This model is introduced in <a href="https://iopscience.iop.org/article/10.1088/0305-4470/31/34/015">Reiterer et al.</a>. We reduce this system to an order of 7 from 9 for the analysis. Here are some cool visualizations of the model&#39;s dynamics.</p><p>&lt;img src=&quot;assets/images/ChaosGizmo/9dim<em>lorenz</em>3d.svg&quot; width=&quot;300&quot; align=&quot;right&quot;&gt; &lt;img src=&quot;assets/images/ChaosGizmo/9dim<em>lorenz</em>frame1.svg&quot; width=&quot;300&quot; align=&quot;right&quot;&gt; &lt;img src=&quot;assets/images/ChaosGizmo/9dim<em>lorenz</em>frame2.svg&quot; width=&quot;300&quot; align=&quot;right&quot;&gt; &lt;img src=&quot;assets/images/ChaosGizmo/9dim<em>lorenz</em>frame3.svg&quot; width=&quot;300&quot; align=&quot;right&quot;&gt;</p><pre><code class="language-julia hljs">using LinearAlgebra: svd, I
using LiftAndLearn
const LnL = LiftAndLearn

# Define the 9-dimensional Lorenz system
a = 0.5  # wave number in the horizontal direction
b1 = 4*(1+a^2) / (1+2*a^2)
b2 = (1+2*a^2) / (2*(1+a^2))
b3 = 2*(1-a^2) / (1+a^2)
b4 = a^2 / (1+a^2)
b5 = 8*a^2 / (1+2*a^2)
b6 = 4 / (1+2*a^2)

sigma = 0.5  # Prandtl number
r = 15.10  # reduced Rayleigh number

n = 9  # dimension of the system
# Linear operator
A = zeros(n,n)
A[1,1] = -sigma * b1
A[1,7] = -sigma * b2
A[2,2] = -sigma
A[2,9] = -sigma / 2
A[3,3] = -sigma * b1
A[3,8] = sigma * b2
A[4,4] = -sigma
A[4,9] = sigma / 2
A[5,5] = -sigma * b5
A[6,6] = -b6
A[7,1] = -r
A[7,7] = -b1
A[8,3] = r
A[8,8] = -b1
A[9,2] = -r
A[9,4] = r
A[9,9] = -1

# Quadratic operator
indices = [
    (2,4,1), (4,4,1), (3,5,1),
    (1,4,2), (2,5,2), (4,5,2),
    (2,4,3), (2,2,3), (1,5,3),
    (2,3,4), (2,5,4), (4,5,4),
    (2,2,5), (4,4,5),
    (2,9,6), (4,9,6),
    (5,8,7), (4,9,7),
    (5,7,8), (2,9,8),
    (2,6,9), (4,6,9), (4,7,9), (2,8,9)
]
values = [
    -1, b4, b3,
    1, -1, 1,
    1, -b4, -b3,
    -1, -1, 1,
    0.5, -0.5,
    1, -1,
    2, -1,
    -2, 1,
    -2, 2, 1, -1
]
H = LnL.makeQuadOp(n, indices, values; which_quad_term=&quot;H&quot;)
F = LnL.makeQuadOp(n, indices, values; which_quad_term=&quot;F&quot;)
lorenz9_ops = LnL.operators(A=A, H=H, F=F)


# Define some helper functions
function lorenz_jacobian(ops::LnL.operators, x::AbstractArray)
    n = size(x,1)
    return ops.A + ops.H * kron(I(n),x) + ops.H*kron(x,I(n))
end

function lorenz_integrator(ops::LnL.operators, tspan::AbstractArray, IC::Array; params...)
    K = length(tspan)
    N = size(IC,1)
    f = let A = ops.A, H = ops.H, F = ops.F
        if ops.H == 0
            (x, t) -&gt; A*x + F*LnL.vech(x*x&#39;)
        else
            (x, t) -&gt; A*x + H*kron(x,x)
        end
    end
    xk = zeros(N,K)
    xk[:,1] = IC

    for k in 2:K
        timestep = tspan[k] - tspan[k-1]
        k1 = f(xk[:,k-1], tspan[k-1])
        k2 = f(xk[:,k-1] + 0.5 * timestep * k1, tspan[k-1] + 0.5 * timestep)
        k3 = f(xk[:,k-1] + 0.5 * timestep * k2, tspan[k-1] + 0.5 * timestep)
        k4 = f(xk[:,k-1] + timestep * k3, tspan[k-1] + timestep)
        xk[:,k] = xk[:,k-1] + (timestep / 6.0) * (k1 + 2*k2 + 2*k3 + k4)
    end
    return xk
end

# Then construct the intrusive POD-Galerkin reduced model
# Lyapunov exponent of POD reduced model
data1 = lorenz_integrator(lorenz9_ops, 0:1e-2:1e3, 2*rand(9).-1)
data2 = lorenz_integrator(lorenz9_ops, 0:1e-2:1e3, 2*rand(9).-1)
data3 = lorenz_integrator(lorenz9_ops, 0:1e-2:1e3, 2*rand(9).-1)
data4 = lorenz_integrator(lorenz9_ops, 0:1e-2:1e3, 2*rand(9).-1)
data5 = lorenz_integrator(lorenz9_ops, 0:1e-2:1e3, 2*rand(9).-1)
data = hcat(data1, data2, data3, data4, data5)
rmax = 7
Vr = svd(data).U[:,1:rmax]   # choose rmax columns
rom_option = LnL.LS_options(
    system=LnL.sys_struct(is_lin=true, is_quad=true),
)
oprom = LnL.intrusiveMR(lorenz9_ops, Vr, rom_option)


# Now, we can compute the Lyapunov spectrum and the Kaplan-Yorke dimension using the method without the Tangent map
const CG = LnL.ChaosGizmo
x0 = [0.01, 0, 0.01, 0.0, 0.0, 0.0, 0, 0, 0.01]
options = CG.LE_options(N=1e4, τ=1e2, τ0=0.0, Δt=1e-2, m=rmax, T=1e-2, verbose=false, history=true)
λr1, λr1_all = CG.lyapunovExponent(oprom, lorenz_integrator, Vr, x0, options)
dkyr1 = CG.kaplanYorkeDim(λr1; sorted=false)
println(&quot;Kaplan-Yorke dimension (without Jacobian): &quot;, dkyr1)

using Plots
p = plot()
for i in 1:rmax
    plot!(p, λr1_all[i,:], label=&quot;λ$i&quot;, lw=2)
end
plot!(p, xlabel=&quot;reorthonormalization steps&quot;, ylabel=&quot;Lyapunov exponent&quot;, legend=:right, fontfamily=&quot;Computer Modern&quot;)
display(p)

# You can also compute them using the method with the Tangent map.
λr2, λr2_all = CG.lyapunovExponentJacobian(oprom, lorenz_integrator, lorenz_jacobian, Vr&#39; * x0, options)
dkyr2 = CG.kaplanYorkeDim(λr2; sorted=false)
println(&quot;Kaplan-Yorke dimension (with Jacobian): &quot;, dkyr2)

p = plot()
for i in 1:rmax
    plot!(p, λr2_all[i,:], label=&quot;λ$i&quot;, lw=2)
end
plot!(p, xlabel=&quot;reorthonormalization steps&quot;, ylabel=&quot;Lyapunov exponent&quot;, legend=:right, fontfamily=&quot;Computer Modern&quot;)
display(p)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Kaplan-Yorke dimension (without Jacobian): 2.063988293798444
GKS: cannot open display - headless operation mode active
Kaplan-Yorke dimension (with Jacobian): 1.512420398877544</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../chaosgizmo/">« Introduction</a><a class="docs-footer-nextpage" href="../../../models/Heat1D/">Heat1D »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 23 April 2024 16:27">Tuesday 23 April 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
